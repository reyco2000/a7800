"""
AddressSpace -- page-granularity memory-mapping system for EMU7800.
Ported from the C# AddressSpace class.

The address space is divided into fixed-size *pages*.  Each page points to an
:class:`~emu7800.core.devices.IDevice` instance.  When the CPU (or Maria DMA)
reads or writes an address the AddressSpace resolves the page, then delegates
to the device mapped there.

Typical configurations:

* **Atari 7800** -- 16-bit address space (64 KB), 64-byte pages
  ``addr_space_shift=16, page_shift=6``  ->  1024 pages
* **Atari 2600** -- 13-bit address space (8 KB), 64-byte pages
  ``addr_space_shift=13, page_shift=6``  ->  128 pages

A *snooper* device receives every read and write before the normal device.
This is used by TIA / RIOT on the 7800 to let them observe bus traffic
generated by Maria DMA without being the primary mapped device at that
address.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Optional

from emu7800.core.devices import IDevice, NullDevice

if TYPE_CHECKING:
    # Avoid circular imports at runtime -- these are only needed for type
    # checkers and IDE autocompletion.
    from emu7800.core.devices import Bios7800


class AddressSpace:
    """Page-granularity memory map for an emulated Atari system.

    Parameters
    ----------
    machine:
        Back-reference to the owning machine object.  Stored but not
        interpreted by AddressSpace itself.
    addr_space_shift:
        Number of address bits.  16 for the 7800 (64 KB), 13 for the 2600
        (8 KB, because A13-A15 are not decoded).
    page_shift:
        Log-base-2 of the page size in bytes.  6 gives 64-byte pages.
    """

    # ------------------------------------------------------------------
    # Construction
    # ------------------------------------------------------------------

    def __init__(
        self,
        machine: object,
        addr_space_shift: int = 16,
        page_shift: int = 6,
    ) -> None:
        # Back-reference to the machine (CPU, Maria, TIA, etc.)
        self.machine: object = machine

        # Address-space geometry
        self.addr_space_shift: int = addr_space_shift
        self.page_shift: int = page_shift

        self.addr_space_size: int = 1 << addr_space_shift
        self.addr_space_mask: int = self.addr_space_size - 1
        self.page_size: int = 1 << page_shift

        # Number of pages that cover the entire address space
        self._page_count: int = self.addr_space_size >> page_shift

        # The null device is used for unmapped pages and as the default
        # snooper (it silently ignores all accesses).
        self._null_device: NullDevice = NullDevice()

        # Page table: list of IDevice, one entry per page.
        self._memory_map: list[IDevice] = [
            self._null_device
        ] * self._page_count

        # Snooper device -- sees every read/write before the mapped device.
        self._snooper: IDevice = self._null_device

        # Data bus state -- retains the last byte that flowed across the bus.
        # Open-bus reads on real hardware return whatever was last driven on
        # the data bus; this attribute approximates that behaviour.
        self.data_bus_state: int = 0

        # Maria DMA read latch.  Maria stores the result of DMA fetches
        # here so the rest of the system can inspect it.
        self.maria_read: int = 0

        # Cart reference (set by map_cart)
        self._cart: Optional[object] = None

    # ------------------------------------------------------------------
    # Snooper property
    # ------------------------------------------------------------------

    @property
    def snooper(self) -> IDevice:
        """The snooper device that observes all bus traffic."""
        return self._snooper

    @snooper.setter
    def snooper(self, device: IDevice) -> None:
        self._snooper = device

    # ------------------------------------------------------------------
    # Memory-map property (read-only view)
    # ------------------------------------------------------------------

    @property
    def memory_map(self) -> list[IDevice]:
        """Direct access to the page table (list of IDevice, one per page)."""
        return self._memory_map

    # ------------------------------------------------------------------
    # Read / Write
    # ------------------------------------------------------------------

    def __getitem__(self, addr: int) -> int:
        """Read a byte from the address space.

        1. The snooper is notified of the read.
        2. The page is looked up and the mapped device is read.
        3. The byte is stored in :attr:`data_bus_state` and returned.
        """
        addr &= self.addr_space_mask
        # Let the snooper observe (return value is intentionally discarded).
        self._snooper[addr]
        # Look up the device for this page and read.
        page = addr >> self.page_shift
        value = self._memory_map[page][addr] & 0xFF
        self.data_bus_state = value
        return value

    def __setitem__(self, addr: int, value: int) -> None:
        """Write a byte to the address space.

        1. The snooper is notified of the write.
        2. The page is looked up and the mapped device is written.
        3. The byte is stored in :attr:`data_bus_state`.
        """
        addr &= self.addr_space_mask
        value &= 0xFF
        self.data_bus_state = value
        # Let the snooper observe.
        self._snooper[addr] = value
        # Write through to the mapped device.
        page = addr >> self.page_shift
        self._memory_map[page][addr] = value

    # ------------------------------------------------------------------
    # Mapping helpers
    # ------------------------------------------------------------------

    def map(self, base_addr: int, size: int, device: IDevice) -> None:
        """Map *device* to a contiguous range of pages.

        Parameters
        ----------
        base_addr:
            The first address that should be handled by *device*.  It is
            masked to the address-space size and should be page-aligned,
            though this is not enforced.
        size:
            The number of bytes to map (should be a multiple of
            :attr:`page_size`).
        device:
            The device that will service reads/writes in this range.
        """
        base_addr &= self.addr_space_mask
        first_page = base_addr >> self.page_shift
        num_pages = max(1, size >> self.page_shift)
        for i in range(num_pages):
            page_index = (first_page + i) % self._page_count
            self._memory_map[page_index] = device

    def map_cart(self, cart: object) -> None:
        """Attach a cartridge to the address space.

        If *cart* exposes a ``map(address_space)`` method it is called so
        that the cartridge can set up its own (potentially bank-switched)
        mapping.  Otherwise the cartridge is mapped into the default ROM
        window ``0x4000 .. 0xFFFF`` (48 KB).

        Parameters
        ----------
        cart:
            A cartridge object.  Expected to implement
            :class:`~emu7800.core.devices.IDevice` and optionally a
            ``map(address_space)`` method.
        """
        self._cart = cart

        if hasattr(cart, "map") and callable(cart.map):
            cart.map(self)
        else:
            # Default: map the cart into 0x4000 - 0xFFFF (48 KB window).
            # This covers the standard Atari 7800 cartridge ROM region.
            default_base: int = 0x4000
            default_size: int = self.addr_space_size - default_base
            if isinstance(cart, IDevice):
                self.map(default_base, default_size, cart)

    # ------------------------------------------------------------------
    # Bulk / utility
    # ------------------------------------------------------------------

    def reset(self) -> None:
        """Reset the address space to its initial empty state.

        All pages are remapped to :class:`NullDevice`, the snooper is
        cleared, and bus state is zeroed.
        """
        for i in range(self._page_count):
            self._memory_map[i] = self._null_device
        self._snooper = self._null_device
        self.data_bus_state = 0
        self.maria_read = 0

    def get_device_at(self, addr: int) -> IDevice:
        """Return the device mapped to the page containing *addr*."""
        addr &= self.addr_space_mask
        return self._memory_map[addr >> self.page_shift]

    # ------------------------------------------------------------------
    # Dunder helpers
    # ------------------------------------------------------------------

    def __repr__(self) -> str:
        return (
            f"AddressSpace("
            f"addr_space_shift={self.addr_space_shift}, "
            f"page_shift={self.page_shift}, "
            f"pages={self._page_count})"
        )
